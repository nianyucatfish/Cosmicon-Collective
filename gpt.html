<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Lenticular Frame Preview</title>
    <style>
        body {
            margin: 0;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }

        #stage {
            width: 524px;
            height: 753px;
            position: relative;
        }

        canvas {
            display: block;
        }

        #controls {
            width: 524px;
            margin-top: 20px;
        }
    </style>
</head>

<body>

    <div id="stage"></div>
    <div id="controls">
        <input type="range" id="frameSlider" min="0" max="17" value="0" style="width:100%">
    </div>

    <script type="module">
        import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";

        const WIDTH = 524;
        const HEIGHT = 753;
        const TOTAL_FRAMES = 18;
        const MAX_ANGLE = 12; // 总旋转角度

        const stage = document.getElementById("stage");

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(WIDTH, HEIGHT);
        renderer.autoClear = false;
        stage.appendChild(renderer.domElement);

        /* =========================
           主场景
        ========================= */

        const mainScene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30, WIDTH / HEIGHT, 0.1, 100);
        camera.position.set(0, 0, 8);

        const ambient = new THREE.AmbientLight(0xffffff, 1.2);
        mainScene.add(ambient);

        /* =========================
           Overlay 场景
        ========================= */

        const overlayScene = new THREE.Scene();
        const orthoCamera = new THREE.OrthographicCamera(
            -WIDTH / 2, WIDTH / 2,
            HEIGHT / 2, -HEIGHT / 2,
            -10, 10
        );
        orthoCamera.position.z = 5;

        /* =========================
           贴图
        ========================= */

        const loader = new THREE.TextureLoader();
        const bgTex = loader.load("背景.png");
        const charTex = loader.load("流萤.png");
        const maskTex = loader.load("card-border-mask.png");

        bgTex.colorSpace = THREE.SRGBColorSpace;
        charTex.colorSpace = THREE.SRGBColorSpace;

        /* =========================
           主卡组
        ========================= */

        const cardGroup = new THREE.Group();
        mainScene.add(cardGroup);

        const ratio = WIDTH / HEIGHT;
        const cardHeight = 4.2;
        const cardWidth = cardHeight * ratio;
        const planeGeo = new THREE.PlaneGeometry(cardWidth, cardHeight);

        // 背景
        const bgMesh = new THREE.Mesh(
            planeGeo,
            new THREE.MeshBasicMaterial({ map: bgTex })
        );
        bgMesh.position.z = -0.5;
        cardGroup.add(bgMesh);

        // 角色 inside
        const charInside = new THREE.Mesh(
            planeGeo,
            new THREE.MeshBasicMaterial({ map: charTex, transparent: true })
        );
        charInside.position.z = 0.1;
        cardGroup.add(charInside);

        // 角色 outside（模拟冲出）
        const charOutside = new THREE.Mesh(
            planeGeo,
            new THREE.MeshBasicMaterial({ map: charTex, transparent: true })
        );
        charOutside.position.z = 0.6;
        cardGroup.add(charOutside);

        /* =========================
           牌框 Shader（屏幕空间）
        ========================= */

        const gradientTex = new THREE.CanvasTexture(generateGradient());
        gradientTex.colorSpace = THREE.SRGBColorSpace;

        const frameMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uGradient: { value: gradientTex },
                uMask: { value: maskTex },
                uViewFactor: { value: 0 }
            },
            vertexShader: `
varying vec2 vUv;
void main(){
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
`,
            fragmentShader: `
uniform sampler2D uGradient;
uniform sampler2D uMask;
uniform float uViewFactor;
varying vec2 vUv;

void main(){
    float mask = texture2D(uMask,vUv).a;
    if(mask<0.1) discard;

    vec2 uvShift = vUv + vec2(uViewFactor*0.3,0.0);
    vec3 col = texture2D(uGradient,uvShift).rgb;
    gl_FragColor = vec4(col,mask);
}
`,
            transparent: true
        });

        const frameMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(WIDTH, HEIGHT),
            frameMaterial
        );
        overlayScene.add(frameMesh);

        /* =========================
           渲染
        ========================= */

        function renderFrame(frameIndex) {

            const t = frameIndex / (TOTAL_FRAMES - 1);
            const angle = THREE.MathUtils.degToRad(t * MAX_ANGLE);

            cardGroup.rotation.y = angle;

            frameMaterial.uniforms.uViewFactor.value = t;

            renderer.clear();
            renderer.render(mainScene, camera);
            renderer.clearDepth();
            renderer.render(overlayScene, orthoCamera);
        }

        renderFrame(0);

        /* =========================
           滑块控制
        ========================= */

        const slider = document.getElementById("frameSlider");
        slider.addEventListener("input", e => {
            renderFrame(parseInt(e.target.value));
        });

        /* =========================
           生成渐变纹理
        ========================= */

        function generateGradient() {
            const canvas = document.createElement("canvas");
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext("2d");
            const g = ctx.createLinearGradient(0, 0, 1024, 1024);
            g.addColorStop(0, "#ffffff");
            g.addColorStop(0.3, "#ff9a9e");
            g.addColorStop(0.6, "#a1c4fd");
            g.addColorStop(1, "#ffffff");
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 1024, 1024);
            return canvas;
        }

    </script>
</body>

</html>