<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>流萤 - 3D Web 实验版</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1b26;
            font-family: sans-serif;
        }

        .card-stage {
            width: 524px;
            height: 753px;
            position: relative;
            border-radius: 20px;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            background: radial-gradient(circle at 50% 20%, #2f3244 0%, #1f2130 55%, #171823 100%);
        }

        #scene {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hint {
            position: absolute;
            left: 50%;
            bottom: 14px;
            transform: translateX(-50%);
            z-index: 2;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.75);
            font-size: 12px;
            letter-spacing: 0.6px;
        }
    </style>
</head>

<body>

    <div class="card-stage" id="cardStage">
        <div id="scene"></div>
        <div class="hint">Three.js 全元素内部平面</div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';

        const stage = document.getElementById('cardStage');
        const host = document.getElementById('scene');

        const width = 524;
        const height = 753;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30, width / height, 0.1, 100);
        camera.position.set(0, 0, 8.4);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, stencil: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(width, height);
        host.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.1);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 0.6);
        keyLight.position.set(0.4, 1, 2);
        scene.add(keyLight);

        const textureLoader = new THREE.TextureLoader();
        const bgTexture = textureLoader.load('背景.png');
        const characterTexture = textureLoader.load('流萤.png');
        const frameMaskTexture = textureLoader.load('card-border-mask.png');
        bgTexture.colorSpace = THREE.SRGBColorSpace;
        characterTexture.colorSpace = THREE.SRGBColorSpace;
        frameMaskTexture.colorSpace = THREE.NoColorSpace;

        const createFrameGradientTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 1024, 1024);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.15, 'rgba(255,154,158,1)');
            gradient.addColorStop(0.35, 'rgba(161,196,253,1)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.65, 'rgba(212,252,121,1)');
            gradient.addColorStop(0.85, 'rgba(255,203,242,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,1)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 1024);

            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            return texture;
        };

        const createGlareTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, 1024, 1024);

            const cell = 32;
            for (let y = 0; y < 1024; y += cell) {
                for (let x = 0; x < 1024; x += cell) {
                    const isEven = ((x / cell) + (y / cell)) % 2 === 0;
                    ctx.fillStyle = isEven ? 'rgba(255,255,255,0.16)' : 'rgba(255,255,255,0.03)';
                    ctx.fillRect(x, y, cell, cell);
                }
            }


            const sheen = ctx.createLinearGradient(0, 0, 1024, 1024);
            sheen.addColorStop(0.2, 'rgba(255,255,255,0)');
            sheen.addColorStop(0.45, 'rgba(255,255,255,0.22)');
            sheen.addColorStop(0.55, 'rgba(255,255,255,0.08)');
            sheen.addColorStop(0.8, 'rgba(255,255,255,0)');
            ctx.fillStyle = sheen;
            ctx.fillRect(0, 0, 1024, 1024);

            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(30, 40);
            return texture;
        };

        const frameGradientTexture = createFrameGradientTexture();
        const glareTexture = createGlareTexture();

        const cardGroup = new THREE.Group();
        scene.add(cardGroup);

        const characterGroup = new THREE.Group();
        cardGroup.add(characterGroup);

        const characterPivot = new THREE.Group();
        characterGroup.add(characterPivot);

        const cardRatio = width / height;
        const cardHeight = 4.2;
        const cardWidth = cardHeight * cardRatio;
        const planeGeometry = new THREE.PlaneGeometry(cardWidth, cardHeight, 1, 1);

        const bgParallaxRange = { x: 0.08, y: 0.08 };
        const characterParallaxRange = { x: 0.2, y: 0.14 };
        const computeOverscan = (rangeX, rangeY, padding = 0.02) => {
            const scaleX = 1 + ((Math.abs(rangeX) * 2) / cardWidth) + padding;
            const scaleY = 1 + ((Math.abs(rangeY) * 2) / cardHeight) + padding;
            return Math.max(scaleX, scaleY);
        };

        const bgOverscan = computeOverscan(bgParallaxRange.x, bgParallaxRange.y, 0.06);
        const characterOverscan = computeOverscan(characterParallaxRange.x, characterParallaxRange.y, 0.05);

        const createRoundedRectShape = (w, h, r) => {
            const shape = new THREE.Shape();
            const x = -w * 0.5;
            const y = -h * 0.5;
            const radius = Math.min(r, Math.min(w, h) * 0.5);

            shape.moveTo(x + radius, y);
            shape.lineTo(x + w - radius, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + radius);
            shape.lineTo(x + w, y + h - radius);
            shape.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
            shape.lineTo(x + radius, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - radius);
            shape.lineTo(x, y + radius);
            shape.quadraticCurveTo(x, y, x + radius, y);
            return shape;
        };

        const contentInset = 0.16;
        const contentMaskGeometry = new THREE.ShapeGeometry(
            createRoundedRectShape(cardWidth - contentInset, cardHeight - contentInset, 0.12)
        );
        const contentMaskMesh = new THREE.Mesh(
            contentMaskGeometry,
            new THREE.MeshBasicMaterial({
                colorWrite: false,
                depthWrite: false,
                depthTest: false,
                stencilWrite: true,
                stencilRef: 1,
                stencilFunc: THREE.AlwaysStencilFunc,
                stencilFail: THREE.ReplaceStencilOp,
                stencilZFail: THREE.ReplaceStencilOp,
                stencilZPass: THREE.ReplaceStencilOp
            })
        );
        contentMaskMesh.position.z = 0.3;
        contentMaskMesh.renderOrder = 1;
        cardGroup.add(contentMaskMesh);

        const applyCardStencilClip = (material) => {
            material.stencilWrite = true;
            material.stencilRef = 1;
            material.stencilFunc = THREE.EqualStencilFunc;
            material.stencilFail = THREE.KeepStencilOp;
            material.stencilZFail = THREE.KeepStencilOp;
            material.stencilZPass = THREE.KeepStencilOp;
        };

        const bgMaterial = new THREE.MeshBasicMaterial({ map: bgTexture });
        applyCardStencilClip(bgMaterial);
        const bgMesh = new THREE.Mesh(planeGeometry, bgMaterial);
        bgMesh.position.z = -0.35;
        bgMesh.scale.set(bgOverscan, bgOverscan, 1);
        bgMesh.renderOrder = 2;
        cardGroup.add(bgMesh);

        const planeMaterial = new THREE.MeshBasicMaterial({
            map: characterTexture,
            transparent: true,
            depthTest: true,
            depthWrite: true
        });
        applyCardStencilClip(planeMaterial);

        const characterPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        characterPlane.position.set(0, cardHeight * 0.5, 0.1);
        characterPlane.scale.set(characterOverscan, characterOverscan, 1);
        characterPlane.renderOrder = 3;
        characterPivot.add(characterPlane);

        characterPivot.position.y = -cardHeight * 0.5;
        const baseTiltX = THREE.MathUtils.degToRad(10);
        characterPivot.rotation.x = baseTiltX;

        const frameMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uGradient: { value: frameGradientTexture },
                uMask: { value: frameMaskTexture },
                uBgOffset: { value: new THREE.Vector2(0.3333, 0.3333) },
                uSheen: { value: 0.5 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uGradient;
                uniform sampler2D uMask;
                uniform vec2 uBgOffset;
                uniform float uSheen;
                varying vec2 vUv;

                void main() {
                    vec2 gradUv = (vUv / 3.0) + uBgOffset;
                    gradUv = clamp(gradUv, vec2(0.0), vec2(1.0));

                    vec3 g1 = texture2D(uGradient, gradUv).rgb;
                    vec3 g2 = texture2D(uGradient, clamp(gradUv + vec2(0.14, -0.08), vec2(0.0), vec2(1.0))).rgb;
                    vec3 metallic = mix(g1, g2, 0.35);

                    float sheenBand = 1.0 - smoothstep(0.0, 0.22, abs(vUv.x - uSheen));
                    float verticalFalloff = 1.0 - smoothstep(0.0, 1.0, abs(vUv.y - 0.5) * 1.55);
                    float sheen = sheenBand * verticalFalloff;
                    metallic += vec3(sheen * 0.42);

                    float rawMaskAlpha = texture2D(uMask, vUv).a;
                    float maskAlpha = smoothstep(0.08, 0.92, rawMaskAlpha);
                    if (maskAlpha < 0.01) discard;
                    gl_FragColor = vec4(metallic, maskAlpha);
                }
            `,
            transparent: true,
            depthTest: true,
            depthWrite: true
        });

        const frameMesh = new THREE.Mesh(planeGeometry, frameMaterial);
        frameMesh.position.z = 0.22;
        frameMesh.renderOrder = 10;
        cardGroup.add(frameMesh);

        const glareMesh = new THREE.Mesh(
            planeGeometry,
            new THREE.MeshBasicMaterial({
                map: glareTexture,
                transparent: true,
                opacity: 0.24,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                depthWrite: false
            })
        );
        glareMesh.position.z = 0.42;
        glareMesh.renderOrder = 100;
        cardGroup.add(glareMesh);

        let targetCardRotX = 0;
        let targetCardRotY = 0;
        let targetNX = 0;
        let targetNY = 0;

        stage.addEventListener('mousemove', (event) => {
            const rect = stage.getBoundingClientRect();
            const nx = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const ny = ((event.clientY - rect.top) / rect.height) * 2 - 1;

            targetCardRotX = THREE.MathUtils.degToRad(-ny * 10);
            targetCardRotY = THREE.MathUtils.degToRad(nx * 10);
            targetNX = nx;
            targetNY = ny;
        });

        stage.addEventListener('mouseleave', () => {
            targetCardRotX = 0;
            targetCardRotY = 0;
            targetNX = 0;
            targetNY = 0;
        });

        const clock = new THREE.Clock();
        function animate() {
            const dt = Math.min(clock.getDelta(), 0.05);
            const smoothing = 1 - Math.exp(-8 * dt);

            cardGroup.rotation.x += (targetCardRotX - cardGroup.rotation.x) * smoothing;
            cardGroup.rotation.y += (targetCardRotY - cardGroup.rotation.y) * smoothing;

            const bgTargetX = targetNX * bgParallaxRange.x;
            const bgTargetY = -targetNY * bgParallaxRange.y;
            bgMesh.position.x += (bgTargetX - bgMesh.position.x) * smoothing;
            bgMesh.position.y += (bgTargetY - bgMesh.position.y) * smoothing;

            const charTargetX = targetNX * characterParallaxRange.x;
            const charTargetY = -targetNY * characterParallaxRange.y;
            characterGroup.position.x += (charTargetX - characterGroup.position.x) * smoothing;
            characterGroup.position.y += (charTargetY - characterGroup.position.y) * smoothing;

            const frameTargetX = targetNX * 0.18;
            const frameTargetY = -targetNY * 0.12;
            frameMesh.position.x += (frameTargetX - frameMesh.position.x) * smoothing;
            frameMesh.position.y += (frameTargetY - frameMesh.position.y) * smoothing;

            const bgPosX = (targetNX + 1) * 0.5;
            const bgPosY = (targetNY + 1) * 0.5;
            const targetOffsetX = bgPosX * (1 - 1 / 2.2);
            const targetOffsetY = bgPosY * (1 - 1 / 2.2);
            frameMaterial.uniforms.uBgOffset.value.x += (targetOffsetX - frameMaterial.uniforms.uBgOffset.value.x) * smoothing;
            frameMaterial.uniforms.uBgOffset.value.y += (targetOffsetY - frameMaterial.uniforms.uBgOffset.value.y) * smoothing;
            frameMaterial.uniforms.uSheen.value += (bgPosX - frameMaterial.uniforms.uSheen.value) * (smoothing * 1.15);

            const glareTargetX = frameTargetX;
            const glareTargetY = frameTargetY;
            glareMesh.position.x += (glareTargetX - glareMesh.position.x) * smoothing;
            glareMesh.position.y += (glareTargetY - glareMesh.position.y) * smoothing;

            glareTexture.offset.x += (((targetNX * 0.6) - glareTexture.offset.x) * smoothing);
            glareTexture.offset.y += (((targetNY * 0.15) - glareTexture.offset.y) * smoothing);

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();
    </script>

</body>

</html>